name: Deploy to Azure

on:
  # Manual trigger
  workflow_dispatch:
    inputs:
      environment:
        description: 'Environment to deploy to'
        required: true
        default: 'dev'
        type: choice
        options:
          - dev
          - prod
  
  # Auto-trigger after build workflow completes (on master branch)
  workflow_run:
    workflows: ["Build and Push Images"]
    branches: [master, devops-setup]
    types:
      - completed

jobs:
  deploy:
    name: Deploy to Azure Container Apps
    runs-on: ubuntu-latest
    # Skip if workflow_run trigger comes from a failed build
    if: ${{ github.event_name != 'workflow_run' || github.event.workflow_run.conclusion == 'success' }}
    permissions:
      actions: read
      contents: read
    
    steps:
      - name: Checkout
        uses: actions/checkout@v4
      
      # Determine environment
      - name: Set Environment
        id: env
        run: |
          if [[ "${{ github.event_name }}" == "workflow_dispatch" ]]; then
            echo "ENV=${{ github.event.inputs.environment }}" >> $GITHUB_OUTPUT
          else
            echo "ENV=dev" >> $GITHUB_OUTPUT
          fi
      
      # Download version artifact if this was triggered by workflow_run
      - name: Download Version Info
        if: ${{ github.event_name == 'workflow_run' }}
        uses: actions/download-artifact@v4
        with:
          name: version-info
          github-token: ${{ secrets.GITHUB_TOKEN }}
          run-id: ${{ github.event.workflow_run.id }}
      
      - name: Extract Version Info
        if: ${{ github.event_name == 'workflow_run' }}
        run: |
          export VERSION=$(grep VERSION version.txt | cut -d= -f2)
          echo "VERSION=$VERSION" >> $GITHUB_ENV
      
      # Login to Azure
      - name: Azure Login
        uses: azure/login@v1
        with:
          creds: ${{ secrets.AZURE_CREDENTIALS }}
      
      # Get resource info
      - name: Get Resource Info
        id: resources
        run: |
          # Set resource group based on environment
          if [[ "${{ steps.env.outputs.ENV }}" == "prod" ]]; then
            RESOURCE_GROUP="nationohprod"
          else
            RESOURCE_GROUP="nohdevjun2025"
          fi
          echo "RESOURCE_GROUP=$RESOURCE_GROUP" >> $GITHUB_OUTPUT
          
          # Get Container App names based on naming convention: {resource_group_name}{service}
          API_APP="${RESOURCE_GROUP}server"
          FRONTEND_APP="${RESOURCE_GROUP}frontend"
          echo "API_APP=$API_APP" >> $GITHUB_OUTPUT
          echo "FRONTEND_APP=$FRONTEND_APP" >> $GITHUB_OUTPUT
          
          # Get ACR details
          ACR_LOGIN_SERVER=$(az acr list -g $RESOURCE_GROUP --query "[0].loginServer" -o tsv)
          echo "ACR_LOGIN_SERVER=$ACR_LOGIN_SERVER" >> $GITHUB_OUTPUT
          
          # Get Application Gateway FQDN (this is the public entry point)
          GATEWAY_FQDN=$(az network public-ip show -g $RESOURCE_GROUP -n "${RESOURCE_GROUP}-app-gateway-ip" --query "dnsSettings.fqdn" -o tsv)
          echo "GATEWAY_FQDN=$GATEWAY_FQDN" >> $GITHUB_OUTPUT
      
      # Update API container app with latest image
      - name: Update API Container App
        run: |
          # If triggered by workflow_run, use the version from artifact
          if [[ -n "$VERSION" ]]; then
            IMAGE_TAG="${{ steps.resources.outputs.ACR_LOGIN_SERVER }}/app.server:$VERSION"
          else
            # Otherwise use the latest tag for the specified environment
            IMAGE_TAG="${{ steps.resources.outputs.ACR_LOGIN_SERVER }}/app.server:${{ steps.env.outputs.ENV }}-latest"
          fi
          
          az containerapp update \
            --name ${{ steps.resources.outputs.API_APP }} \
            --resource-group ${{ steps.resources.outputs.RESOURCE_GROUP }} \
            --image $IMAGE_TAG
      
      # Update Frontend container app with latest image
      - name: Update Frontend Container App
        run: |
          # If triggered by workflow_run, use the version from artifact
          if [[ -n "$VERSION" ]]; then
            IMAGE_TAG="${{ steps.resources.outputs.ACR_LOGIN_SERVER }}/app.client:$VERSION"
          else
            # Otherwise use the latest tag for the specified environment
            IMAGE_TAG="${{ steps.resources.outputs.ACR_LOGIN_SERVER }}/app.client:${{ steps.env.outputs.ENV }}-latest"
          fi
          
          az containerapp update \
            --name ${{ steps.resources.outputs.FRONTEND_APP }} \
            --resource-group ${{ steps.resources.outputs.RESOURCE_GROUP }} \
            --image $IMAGE_TAG
      
      # Run smoke test via Application Gateway (public endpoint)
      - name: Smoke Test
        run: |
          GATEWAY_URL="https://${{ steps.resources.outputs.GATEWAY_FQDN }}"
          
          echo "=== Smoke Test via Application Gateway ==="
          echo "Gateway URL: $GATEWAY_URL"
          echo "Testing through Application Gateway (public entry point)..."
          
          # Wait for Application Gateway to be ready
          echo "Waiting 30 seconds for services to be ready..."
          sleep 30
          
          # Test API health endpoint via Application Gateway (matches container liveness probe)
          echo "Testing API health endpoint: $GATEWAY_URL/api/api-health"
          API_HEALTH=$(curl -s -o /dev/null -w "%{http_code}" --max-time 30 --retry 3 --retry-delay 10 "$GATEWAY_URL/api/api-health" || echo "failed")
          echo "API health check status: $API_HEALTH"
          
          # Test Frontend via Application Gateway
          echo "Testing Frontend: $GATEWAY_URL/"
          FRONTEND_STATUS=$(curl -s -o /dev/null -w "%{http_code}" --max-time 30 --retry 3 --retry-delay 10 "$GATEWAY_URL/" || echo "failed")
          echo "Frontend status: $FRONTEND_STATUS"
          
          # Test Keycloak auth endpoint via Application Gateway
          echo "Testing Keycloak: $GATEWAY_URL/auth/realms/master"
          AUTH_STATUS=$(curl -s -o /dev/null -w "%{http_code}" --max-time 30 --retry 3 --retry-delay 10 "$GATEWAY_URL/auth/realms/master" || echo "failed")
          echo "Auth status: $AUTH_STATUS"
          
          # Detailed debugging if tests fail
          if [[ "$API_HEALTH" != "200" && "$FRONTEND_STATUS" != "200" && "$AUTH_STATUS" != "200" ]]; then
            echo "=== All services failed - debugging ==="
            echo "Checking if Application Gateway is accessible..."
            curl -I --max-time 10 "$GATEWAY_URL" || echo "Gateway not accessible"
            
            echo "Checking DNS resolution..."
            nslookup ${{ steps.resources.outputs.GATEWAY_FQDN }} || echo "DNS resolution failed"
            
            exit 1
          elif [[ "$API_HEALTH" != "200" || "$FRONTEND_STATUS" != "200" ]]; then
            echo "=== Some services failed but gateway is responsive ==="
            echo "This is expected during initial deployment while containers start up"
            echo "Frontend: $FRONTEND_STATUS, API: $API_HEALTH, Auth: $AUTH_STATUS"
          else
            echo "=== Smoke tests passed! ==="
            echo "All services are accessible via Application Gateway"
          fi

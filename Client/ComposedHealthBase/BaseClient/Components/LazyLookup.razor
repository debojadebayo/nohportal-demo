@namespace ComposedHealthBase.BaseClient.Components
@using ComposedHealthBase.BaseClient.Services
@using ComposedHealthBase.BaseClient.Enums
@using ComposedHealthBase.Shared.DTOs
@using ComposedHealthBase.Shared.Interfaces
@using System.Linq.Expressions
@using MudBlazor
@typeparam TDto where TDto : IDto, ILazyLookup
@inject ILazyLookupService<TDto> LookupService

@switch (FieldType)
{
    case LazyLookupEnum.Text:
        <MudText>@(SelectedItem?.DisplayName ?? "(Not set)")</MudText>
        break;
    case LazyLookupEnum.ReadOnly:
        <MudField Variant="Variant.Outlined" Label="@Label">@(SelectedItem?.DisplayName ?? "(Not set)")</MudField>
        break;
    case LazyLookupEnum.Search:
        <MudAutocomplete T="Guid" ToStringFunc="@LookupService.ItemToString" Label="@Label" Value="@ItemId"
            ValueChanged="@OnItemChanged" SearchFunc="@SearchItems" ShowProgressIndicator="true"
            ProgressIndicatorColor="Color.Default" AdornmentIcon="@Icons.Material.Filled.Search"/>
        break;
    case LazyLookupEnum.Select:
        <MudSelect T="Guid" Value="@ItemId" ValueChanged="@OnItemChanged" Label="@Label">
            <MudSelectItem Value="@Guid.Empty">Not selected</MudSelectItem>
            @foreach (var item in _items)
            {
                <MudSelectItem Value="@(((IDto)item).Id)">@item.DisplayName</MudSelectItem>
            }
        </MudSelect>
        break;
    default:
        <MudText>(Not set)</MudText>
        break;
}

@code {
    [Parameter] public LazyLookupEnum FieldType { get; set; } = LazyLookupEnum.Text;
    [Parameter] public Guid ItemId { get; set; } = Guid.Empty;
    [Parameter] public string Label { get; set; } = "";
    [Parameter] public EventCallback<Guid> ItemIdChanged { get; set; }
    [Parameter] public EventCallback<TDto?> SelectedItemChanged { get; set; }
    [Parameter] public Expression<Func<Guid>>? ItemIdValueExpression { get; set; }
    [Parameter] public Guid? TenantConstraint { get; set; }
    [Parameter] public Guid? SubjectConstraint { get; set; }

    public TDto? SelectedItem { get; set; }
    private List<TDto> _items = new List<TDto>();
    
    // Track previous parameter values to avoid unnecessary API calls
    private Guid _previousItemId = Guid.Empty;
    private Guid? _previousTenantConstraint = null;
    private Guid? _previousSubjectConstraint = null;
    private LazyLookupEnum _previousFieldType = LazyLookupEnum.Text;
    
    protected override async Task OnParametersSetAsync()
    {
        // Only make API calls if relevant parameters have actually changed
        bool itemIdChanged = ItemId != _previousItemId;
        bool tenantConstraintChanged = TenantConstraint != _previousTenantConstraint;
        bool subjectConstraintChanged = SubjectConstraint != _previousSubjectConstraint;
        bool fieldTypeChanged = FieldType != _previousFieldType;
        
        // Only proceed if something actually changed
        if (!itemIdChanged && !tenantConstraintChanged && !subjectConstraintChanged && !fieldTypeChanged)
        {
            return; // No changes, skip processing
        }
        
        bool stateChanged = false;
        
        if (itemIdChanged || tenantConstraintChanged || subjectConstraintChanged)
        {
            if (ItemId != Guid.Empty)
            {
                SelectedItem = await LookupService.GetItemById(ItemId, CancellationToken.None);
            }
            else
            {
                SelectedItem = default;
            }
            stateChanged = true;
        }
        
        if (fieldTypeChanged || (FieldType == LazyLookupEnum.Select && (tenantConstraintChanged || subjectConstraintChanged)))
        {
            if (FieldType == LazyLookupEnum.Select)
            {
                _items = (await LookupService.GetAllItems(CancellationToken.None)).ToList();
            }
            stateChanged = true;
        }
        
        // Update previous values
        _previousItemId = ItemId;
        _previousTenantConstraint = TenantConstraint;
        _previousSubjectConstraint = SubjectConstraint;
        _previousFieldType = FieldType;
        
        // Only call StateHasChanged if we actually changed something
        if (stateChanged)
        {
            StateHasChanged();
        }
    }
    
    private async Task<IEnumerable<Guid>> SearchItems(string value, CancellationToken cancellationToken)
    {
        return await LookupService.ItemSearch(value, cancellationToken, TenantConstraint, SubjectConstraint);
    }

    private async Task OnItemChanged(Guid value)
    {
        if (value != Guid.Empty)
        {
            SelectedItem = await LookupService.GetItemById(value, CancellationToken.None);
        }
        else
        {
            SelectedItem = default;
        }
        ItemId = value;
        await ItemIdChanged.InvokeAsync(value);
        await SelectedItemChanged.InvokeAsync(SelectedItem);
    }
}
